[
    {
        "title": "Client",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8888);\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  // Close the socket\n  close(clientSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Server",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8888);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Chat Server",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8888);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    // Handle client messages\n    while (1) {\n      memset(buffer, 0, sizeof(buffer));\n\n      if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n        error(\"Failed to read from socket.\");\n\n      printf(\"Client message: %s\", buffer);\n\n      // Check if client wants to exit\n      if (strncmp(buffer, \"exit\", 4) == 0)\n        break;\n\n      // Reply to the client\n      printf(\"Enter your reply: \");\n      fgets(buffer, sizeof(buffer), stdin);\n\n      if (write(clientSocket, buffer, strlen(buffer)) < 0)\n        error(\"Failed to write to socket.\");\n    }\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Chat Client",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8888);\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  while (1) {\n    printf(\"Enter message: \");\n    memset(buffer, 0, sizeof(buffer));\n    fgets(buffer, sizeof(buffer), stdin);\n\n    // Send message to the server\n    if (write(clientSocket, buffer, strlen(buffer)) < 0)\n      error(\"Failed to write to socket.\");\n\n    // Receive reply from the server\n    memset(buffer, 0, sizeof(buffer));\n    if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n      error(\"Failed to read from socket.\");\n\n    printf(\"Server reply: %s\\n\", buffer);\n\n    // Check if user wants to exit\n    if (strncmp(buffer, \"exit\", 4) == 0)\n      break;\n  }\n\n  // Close the socket\n  close(clientSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Hamming Server",
        "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include<math.h>\nusing namespace std;\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\n// Function to calculate parity\nchar calcHam(int position, int totalBits, char code[]) {\n  int count = 0, i, j;\n  i = totalBits - position;\n\n  while (i >= 0) {\n    for (j = i; j > i - position; j--) {\n      if (code[j] == '1') {\n        count++;\n      }\n    }\n    i = i - 2 * position;\n  }\n\n  // Check if count is even\n  if (count % 2 == 0) {\n    return '0';\n  } else {\n    return '1';\n  }\n}\n\nint checkHamming(char dataatrec[]) {\n  int size = 0;\n  int i = 0;\n\n  while (dataatrec[i] != '\\0') {\n    size++;\n    i++;\n  }\n\n  int k = 0;\n  int flag = 1;\n  int errorBit;\n\n  for (i = 0; i < size; i++) {\n    if (i == ((int)pow(2, k) - 1)) {\n      if (calcHam(i + 1, size, dataatrec) != '0') {\n        flag = 0;\n        break;\n      }\n      k++;\n    }\n  }\n\n  if (flag == 1) {\n    cout << \"No error\" << endl;\n  } else {\n    cout << \"Error in the hamming code\" << endl;\n  }\n\n  return flag;\n}\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n  char buffer[1024];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8882);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    memset(buffer, 0, sizeof(buffer));\n    if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n      error(\"Failed to read from socket.\");\n\n    checkHamming(buffer);\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Hamming Client",
        "code": "#include <cstdio>\n#include<iostream>\n#include <cstdlib>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <math.h>\nusing namespace std;\n#define BUFFER_SIZE 1024\n\nchar input[32];\nchar code[32];\n\nchar calc_ham(int position, int totalBits) {\n  int count = 0, i, j;\n  i = totalBits - position;\n\n  while (i >= 0) {\n    // Counter number of 1's\n    for (j = i; j > i - position; j--) {\n      if (code[j] == '1') {\n        count++;\n      }\n    }\n    i = i - 2 * position;\n  }\n\n  // Check if count is even\n  if (count % 2 == 0) {\n    return '0';\n  } else {\n    return '1';\n  }\n}\n\nvoid hamming() {\n  int n, i, parityBits = 0, totalBits = 0;\n\n  cout << \"Enter number of bits in data (maximum 8): \";\n  cin >> n;\n\n  for (i = 0; i < n; i++) {\n    cin >> input[i];\n  }\n\n  i = 0;\n\n  // Hamming code redundant bits criteria: 2^r >= m + r + 1\n  while (n > (int)pow(2, i) - (i + 1)) {\n    i++;\n    parityBits++;\n  }\n\n  totalBits = parityBits + n;\n  int j = 0, k = 0, p = n - 1;\n\n  for (i = 0; i < totalBits; i++) {\n    if (i == ((int)pow(2, k) - 1)) {\n      code[totalBits - i - 1] = '0'; // Set all parity bits to 0;\n      k++;\n    } else {\n      code[totalBits - i - 1] = input[p];\n      j++;\n      p--;\n    }\n  }\n\n  // Calculating the hamming code\n  for (i = 0; i < parityBits; i++) {\n    int position = (int)pow(2, i);\n    char value = calc_ham(position, totalBits);\n    code[totalBits - position] = value;\n  }\n}\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char *buffer;\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8882);\n\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  hamming();\n\n  // Send message to the server\n  if (write(clientSocket, code, strlen(code)) < 0)\n    error(\"Failed to write to socket.\");\n  else\n    cout << \"Sent encoded hamming code \" << code << \" to server successfully \"<< endl;\n\n  close(clientSocket);\n\n  return 0;\n}"
    }              
]