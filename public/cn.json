[
    {
        "title": "Client",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8888);\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  // Close the socket\n  close(clientSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Server",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8888);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Chat Server",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8888);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    // Handle client messages\n    while (1) {\n      memset(buffer, 0, sizeof(buffer));\n\n      if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n        error(\"Failed to read from socket.\");\n\n      printf(\"Client message: %s\", buffer);\n\n      // Check if client wants to exit\n      if (strncmp(buffer, \"exit\", 4) == 0)\n        break;\n\n      // Reply to the client\n      printf(\"Enter your reply: \");\n      fgets(buffer, sizeof(buffer), stdin);\n\n      if (write(clientSocket, buffer, strlen(buffer)) < 0)\n        error(\"Failed to write to socket.\");\n    }\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Chat Client",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define BUFFER_SIZE 1024\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char buffer[BUFFER_SIZE];\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8888);\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  while (1) {\n    printf(\"Enter message: \");\n    memset(buffer, 0, sizeof(buffer));\n    fgets(buffer, sizeof(buffer), stdin);\n\n    // Send message to the server\n    if (write(clientSocket, buffer, strlen(buffer)) < 0)\n      error(\"Failed to write to socket.\");\n\n    // Receive reply from the server\n    memset(buffer, 0, sizeof(buffer));\n    if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n      error(\"Failed to read from socket.\");\n\n    printf(\"Server reply: %s\\n\", buffer);\n\n    // Check if user wants to exit\n    if (strncmp(buffer, \"exit\", 4) == 0)\n      break;\n  }\n\n  // Close the socket\n  close(clientSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Hamming Server",
        "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include<math.h>\nusing namespace std;\n#define MAX_CLIENTS 5\n#define BUFFER_SIZE 1024\n\n// Function to calculate parity\nchar calcHam(int position, int totalBits, char code[]) {\n  int count = 0, i, j;\n  i = totalBits - position;\n\n  while (i >= 0) {\n    for (j = i; j > i - position; j--) {\n      if (code[j] == '1') {\n        count++;\n      }\n    }\n    i = i - 2 * position;\n  }\n\n  // Check if count is even\n  if (count % 2 == 0) {\n    return '0';\n  } else {\n    return '1';\n  }\n}\n\nint checkHamming(char dataatrec[]) {\n  int size = 0;\n  int i = 0;\n\n  while (dataatrec[i] != '\\0') {\n    size++;\n    i++;\n  }\n\n  int k = 0;\n  int flag = 1;\n  int errorBit;\n\n  for (i = 0; i < size; i++) {\n    if (i == ((int)pow(2, k) - 1)) {\n      if (calcHam(i + 1, size, dataatrec) != '0') {\n        flag = 0;\n        break;\n      }\n      k++;\n    }\n  }\n\n  if (flag == 1) {\n    cout << \"No error\" << endl;\n  } else {\n    cout << \"Error in the hamming code\" << endl;\n  }\n\n  return flag;\n}\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int serverSocket, clientSocket;\n  struct sockaddr_in serverAddress, clientAddress;\n  socklen_t clientLength;\n  char buffer[1024];\n\n  // Create socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (serverSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_addr.s_addr = INADDR_ANY;\n  serverAddress.sin_port = htons(8882);\n\n  // Bind the socket\n  if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to bind.\");\n\n  // Listen for incoming connections\n  listen(serverSocket, MAX_CLIENTS);\n\n  printf(\"Server listening on port 8888...\\n\");\n\n  while (1) {\n    // Accept connection from client\n    clientLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientLength);\n    if (clientSocket < 0)\n      error(\"Failed to accept connection.\");\n\n    printf(\"New client connected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n\n    memset(buffer, 0, sizeof(buffer));\n    if (read(clientSocket, buffer, sizeof(buffer)) < 0)\n      error(\"Failed to read from socket.\");\n\n    checkHamming(buffer);\n\n    // Close the client socket\n    close(clientSocket);\n    printf(\"Client disconnected: %s\\n\", inet_ntoa(clientAddress.sin_addr));\n  }\n\n  // Close the server socket\n  close(serverSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Hamming Client",
        "code": "#include <cstdio>\n#include<iostream>\n#include <cstdlib>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <math.h>\nusing namespace std;\n#define BUFFER_SIZE 1024\n\nchar input[32];\nchar code[32];\n\nchar calc_ham(int position, int totalBits) {\n  int count = 0, i, j;\n  i = totalBits - position;\n\n  while (i >= 0) {\n    // Counter number of 1's\n    for (j = i; j > i - position; j--) {\n      if (code[j] == '1') {\n        count++;\n      }\n    }\n    i = i - 2 * position;\n  }\n\n  // Check if count is even\n  if (count % 2 == 0) {\n    return '0';\n  } else {\n    return '1';\n  }\n}\n\nvoid hamming() {\n  int n, i, parityBits = 0, totalBits = 0;\n\n  cout << \"Enter number of bits in data (maximum 8): \";\n  cin >> n;\n\n  for (i = 0; i < n; i++) {\n    cin >> input[i];\n  }\n\n  i = 0;\n\n  // Hamming code redundant bits criteria: 2^r >= m + r + 1\n  while (n > (int)pow(2, i) - (i + 1)) {\n    i++;\n    parityBits++;\n  }\n\n  totalBits = parityBits + n;\n  int j = 0, k = 0, p = n - 1;\n\n  for (i = 0; i < totalBits; i++) {\n    if (i == ((int)pow(2, k) - 1)) {\n      code[totalBits - i - 1] = '0'; // Set all parity bits to 0;\n      k++;\n    } else {\n      code[totalBits - i - 1] = input[p];\n      j++;\n      p--;\n    }\n  }\n\n  // Calculating the hamming code\n  for (i = 0; i < parityBits; i++) {\n    int position = (int)pow(2, i);\n    char value = calc_ham(position, totalBits);\n    code[totalBits - position] = value;\n  }\n}\n\nvoid error(const char *message) {\n  perror(message);\n  exit(1);\n}\n\nint main() {\n  int clientSocket;\n  struct sockaddr_in serverAddress;\n  char *buffer;\n\n  // Create socket\n  clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n  if (clientSocket == -1)\n    error(\"Failed to create socket.\");\n\n  // Set up server address\n  serverAddress.sin_family = AF_INET;\n  serverAddress.sin_port = htons(8882);\n\n  if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0)\n    error(\"Invalid address.\");\n\n  // Connect to the server\n  if (connect(clientSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) < 0)\n    error(\"Failed to connect to server.\");\n\n  printf(\"Connected to the server.\\n\");\n\n  hamming();\n\n  // Send message to the server\n  if (write(clientSocket, code, strlen(code)) < 0)\n    error(\"Failed to write to socket.\");\n  else\n    cout << \"Sent encoded hamming code \" << code << \" to server successfully \"<< endl;\n\n  close(clientSocket);\n\n  return 0;\n}"
    },
    {
        "title": "Punitha Ma'am Codes",
        "code": "// Parity Bit\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool findParity(int n) {\n    int count = 0;\n    int temp = n;\n\n    while (temp >= 2) {\n        if (temp & 1)\n            count++;\n        temp = temp >> 1;\n    }\n    return (count % 2) ? true : false;\n}\n\nvector<int> addParity(int n) {\n    vector<int> binaryNum;\n    findParity(n) ? binaryNum.push_back(0) : binaryNum.push_back(1);\n    int bit;\n    while (n > 0) {\n        bit = n % 2;\n        binaryNum.push_back(bit);\n        n = n / 2;\n    }\n    return binaryNum;\n}\n\nint main() {\n    int n;\n    cout << \"Enter a number: \";\n    cin >> n;\n    vector<int> binary = addParity(n);\n    cout << \"Number in Binary With Parity Bit: \";\n    for (int j = binary.size() - 1; j >= 0; j--) {\n        cout << binary[j];\n    }\n    cout << \"\\nParity of \" << n << \" is \" << binary[0] << endl;\n    return 0;\n} \n\n // Checksum\n#include<iostream>\n#include<string.h>\n\nusing namespace std;\n\nint main()\n{\n    char a[20],b[20];\n    char sum[20],complement[20];\n    int i;\n\n    cout << \"Enter first binary string\\n\";\n    cin >> a;\n    cout << \"Enter second binary string\\n\";\n    cin >> b;\n\n    if(strlen(a) == strlen(b))\n    {\n        char carry = '0';\n        int length = strlen(a);\n\n        for(i = length - 1; i >= 0; i--)\n        {\n            if(a[i] == '0' && b[i] == '0' && carry == '0')\n            {\n                sum[i] = '0';\n                carry = '0';\n            }\n            else if(a[i] == '0' && b[i] == '0' && carry == '1')\n            {\n                sum[i] = '1';\n                carry = '0';\n            }\n            else if(a[i] == '0' && b[i] == '1' && carry == '0')\n            {\n                sum[i] = '1';\n                carry = '0';\n            }\n            else if(a[i] == '0' && b[i] == '1' && carry == '1')\n            {\n                sum[i] = '0';\n                carry = '1';\n            }\n            else if(a[i] == '1' && b[i] == '0' && carry == '0')\n            {\n                sum[i] = '1';\n                carry = '0';\n            }\n            else if(a[i] == '1' && b[i] == '0' && carry == '1')\n            {\n                sum[i] = '0';\n                carry = '1';\n            }\n            else if(a[i] == '1' && b[i] == '1' && carry == '0')\n            {\n                sum[i] = '0';\n                carry = '1';\n            }\n            else if(a[i] == '1' && b[i] == '1' && carry == '1')\n            {\n                sum[i] = '1';\n                carry = '1';\n            }\n            else\n                break;\n        }\n        cout << \"\\nSum=\" << carry << sum;\n\n        for(i = 0; i < length; i++)\n        {\n            if(sum[i] == '0')\n                complement[i] = '1';\n            else\n                complement[i] = '0';\n        }\n\n        if(carry == '1')\n            carry = '0';\n        else\n            carry = '1';\n\n        cout << \"\\nChecksum=\" << carry << complement;\n    }\n    else\n        cout << \"\\nWrong input strings\";\n\n    return 0;\n} \n\n // Valid IP Addresses\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool is_decimal_ip(char *ip_address);\nbool is_binary_ip(char *ip_address);\n\nint main() {\n    char ip_address[20];\n    printf(\"Enter an IP address: \");\n    scanf(\"%s\", ip_address);\n    if (is_decimal_ip(ip_address)) {\n        printf(\"Valid decimal IP address.\\n\");\n    } else if (is_binary_ip(ip_address)) {\n        printf(\"Valid binary IP address.\\n\");\n    } else {\n        printf(\"Not a valid IP address.\\n\");\n    }\n    return 0;\n}\n\nbool is_decimal_ip(char *ip_address) {\n    int num;\n    char *token;\n    int count = 0;\n    token = strtok(ip_address, \".\");\n    while (token != NULL) {\n        count++;\n        num = atoi(token);\n        if (num < 0 || num > 255 || (count == 1 && token[0] == '0') || (count > 1 && token[0] == '0')) {\n            printf(\"Not a valid decimal IP address.\\n\");\n            if (num < 0 || num > 255) {\n                printf(\"The number %d is outside the range of 0 to 255.\\n\", num);\n            }\n            if (count == 1 && token[0] == '0') {\n                printf(\"The first decimal number cannot be 0.\\n\");\n            }\n            if (count > 1 && token[0] == '0') {\n                printf(\"The decimal number %d has a leading zero.\\n\", num);\n            }\n            return false;\n        }\n        token = strtok(NULL, \".\");\n    }\n    if (count == 4) {\n        printf(\"Valid decimal IP address.\\n\");\n        return true;\n    } else {\n        printf(\"Not a valid decimal IP address because it does not have exactly 4 decimal numbers.\\n\");\n        return false;\n    }\n}\n\nbool is_binary_ip(char *ip_address) {\n    int num;\n    char *token;\n    int count = 0;\n    token = strtok(ip_address, \".\");\n    while (token != NULL) {\n        count++;\n        num = strtol(token, NULL, 2);\n        if (num < 0 || num > 255) {\n            printf(\"Not a valid binary IP address.\\n\");\n            if (num < 0 || num > 255) {\n                printf(\"The binary number %s is not a valid binary number or is outside the range of 0 to 255.\\n\", token);\n            }\n            return false;\n        }\n        token = strtok(NULL, \".\");\n    }\n    if (count == 4) {\n        printf(\"Valid binary IP address.\\n\");\n        return true;\n    } else {\n        printf(\"Not a valid binary IP address because it does not have exactly 4 binary numbers.\\n\");\n        return false;\n    }\n} \n\n // Classes\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\nbool isValidDecimalIPAddress(const char *ipAddress) {\n    int octets[4];\n    sscanf(ipAddress, \"%d.%d.%d.%d\", &octets[0], &octets[1], &octets[2], &octets[3]);\n\n    for (int i = 0; i < 4; i++) {\n        if (octets[i] < 0 || octets[i] > 255) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool isValidBinaryIPAddress(const char *ipAddress) {\n    if (strlen(ipAddress) != 32) {\n        return false;\n    }\n\n    for (int i = 0; i < 32; i++) {\n        if (ipAddress[i] != '0' && ipAddress[i] != '1') {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    char ipAddress[36];\n    printf(\"Enter the IP address: \");\n    scanf(\"%s\", ipAddress);\n\n    bool isValidDec = isValidDecimalIPAddress(ipAddress);\n    bool isValidBin = isValidBinaryIPAddress(ipAddress);\n\n    if (!isValidDec && !isValidBin) {\n        printf(\"Invalid IP address\\n\");\n        return 0;\n    }\n\n    int firstOctet = 0;\n    if (isValidDec) {\n        sscanf(ipAddress, \"%d\", &firstOctet);\n    } else if (isValidBin) {\n        char octet[9];\n        strncpy(octet, ipAddress, 8);\n        octet[8] = '\\0';\n\n        firstOctet = strtol(octet, NULL, 2);\n    }\n\n    if (isValidDec) {\n        if (firstOctet >= 1 && firstOctet <= 126) {\n            printf(\"Class A (Decimal)\\n\");\n        } else if (firstOctet >= 128 && firstOctet <= 191) {\n            printf(\"Class B (Decimal)\\n\");\n        } else if (firstOctet >= 192 && firstOctet <= 223) {\n            printf(\"Class C (Decimal)\\n\");\n        } else if (firstOctet >= 224 && firstOctet <= 239) {\n            printf(\"Class D (Decimal)\\n\");\n        } else if (firstOctet >= 240 && firstOctet <= 255) {\n            printf(\"Class E (Decimal)\\n\");\n        }\n    }\n\n    if (isValidBin) {\n        if (firstOctet >= 0 && firstOctet <= 127) {\n            printf(\"Class A (Binary)\\n\");\n        } else if (firstOctet >= 128 && firstOctet <= 191) {\n            printf(\"Class B (Binary)\\n\");\n        } else if (firstOctet >= 192 && firstOctet <= 223) {\n            printf(\"Class C (Binary)\\n\");\n        } else if (firstOctet >= 224 && firstOctet <= 239) {\n            printf(\"Class D (Binary)\\n\");\n        } else if (firstOctet >= 240 && firstOctet <= 255) {\n            printf(\"Class E (Binary)\\n\");\n        }\n    }\n\n    return 0;\n} \n\n // Socket Programming using TCP \n // server.c \n\n #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n\n#define BUF_SIZE 1024\n\nvoid error_handler(char *msg) {\n    perror(msg);\n    exit(1);\n}\n\nint main(int argc, char *argv[]) {\n\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <port>\\n\", argv[0]);\n        exit(1);\n    }\n\n    int server_sock, client_sock;\n    struct sockaddr_in server_addr, client_addr;\n\n    // Create socket\n    server_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_sock == -1) {\n        error_handler(\"Failed to create socket\");\n    }\n\n    // Bind socket to address and port\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(atoi(argv[1]));\n\n    if (bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {\n        error_handler(\"Failed to bind socket\");\n    }\n\n    // Listen for connections\n    if (listen(server_sock, 5) == -1) {\n        error_handler(\"Failed to listen for connections\");\n    }\n\n    printf(\"Server started. Waiting for connections...\\n\");\n\n    socklen_t client_addr_size = sizeof(client_addr);\n\n    // Accept incoming connections\n    client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &client_addr_size);\n    if (client_sock == -1) {\n        error_handler(\"Failed to accept connection\");\n    }\n\n    printf(\"Client connected: %s:%d\\n\", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));\n\n    char buf[BUF_SIZE];\n    int read_size;\n\n    while ((read_size = recv(client_sock, buf, BUF_SIZE, 0)) > 0) {\n\n        // Get current time\n        time_t now = time(0);\n        struct tm *local_time = localtime(&now);\n        char timestamp[20];\n        strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d %H:%M:%S\", local_time);\n\n        // Add timestamp to message\n        char message[BUF_SIZE + 38]; // Maximum possible string length is 19 + BUF_SIZE - 1 + 19\n        sprintf(message, \"[%s] %s\", timestamp, buf);\n\n        printf(\"%s\", message);\n\n        // Send message back to client\n        if (send(client_sock, message, strlen(message), 0) == -1) {\n            error_handler(\"Failed to send message\");\n        }\n        \n        memset(buf, 0, sizeof(buf));\n    }\n\n    if (read_size == 0) {\n        puts(\"Client disconnected\");\n    } else {\n        error_handler(\"Failed to receive data\");\n    }\n\n    close(client_sock);\n    close(server_sock);\n\n    return 0;\n} \n\n // client.c \n\n #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define BUF_SIZE 1024\n\nvoid error_handler(char *msg) {\n    perror(msg);\n    exit(1);\n}\n\nint main(int argc, char *argv[]) {\n\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <server_ip> <port>\\n\", argv[0]);\n        exit(1);\n    }\n\n    int sock;\n    struct sockaddr_in server_addr;\n\n    // Create socket\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        error_handler(\"Failed to create socket\");\n    }\n\n    // Configure server address\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(argv[1]);\n    server_addr.sin_port = htons(atoi(argv[2]));\n\n    // Connect to server\n    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {\n        error_handler(\"Failed to connect to server\");\n    }\n\n    printf(\"Connected to server: %s:%d\\n\", argv[1], atoi(argv[2]));\n\n    char message[BUF_SIZE];\n    int read_size;\n\n    while (1) {\n        printf(\"Enter message: \");\n        fgets(message, BUF_SIZE, stdin);\n\n        // Send message to server\n        if (send(sock, message, strlen(message), 0) == -1) {\n            error_handler(\"Failed to send message\");\n        }\n\n        // Receive response from server\n        memset(message, 0, sizeof(message));\n        read_size = recv(sock, message, BUF_SIZE, 0);\n        if (read_size == -1) {\n            error_handler(\"Failed to receive response\");\n        } else if (read_size == 0) {\n            puts(\"Server disconnected\");\n            break;\n        }\n\n        printf(\"Server response: %s\", message);\n    }\n\n    close(sock);\n\n    return 0;\n} \n\n // Socket Programming using UDP \n // server.c  \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n#define CHECKSUM_BITS 5\n\n// Function to calculate the checksum value and return as binary string\nchar* calculateChecksum(const char* binaryCode)\n{\n    unsigned int sum = 0;\n    unsigned int i;\n\n    for (i = 0; i < strlen(binaryCode); i++)\n    {\n        sum += binaryCode[i] - '0';  // Convert character to integer\n        sum %= (1 << CHECKSUM_BITS); // Keep the sum within the bit range\n    }\n\n    // Convert checksum to binary string\n    char* checksumBinary = malloc(CHECKSUM_BITS + 1);\n    for (i = 0; i < CHECKSUM_BITS; i++)\n    {\n        checksumBinary[CHECKSUM_BITS - i - 1] = (sum & (1 << i)) ? '1' : '0';\n    }\n    checksumBinary[CHECKSUM_BITS] = '\\0';\n\n    return checksumBinary;\n}\n\nint main()\n{\n    int sockfd;\n    struct sockaddr_in serverAddr, clientAddr;\n    char buffer[MAX_BUFFER_SIZE];\n\n    // Create UDP socket\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd < 0)\n    {\n        perror(\"Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    memset(&clientAddr, 0, sizeof(clientAddr));\n\n    // Configure server address\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serverAddr.sin_port = htons(12345); // Choose a suitable port number\n\n    // Bind the socket to the server address\n    if (bind(sockfd, (const struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0)\n    {\n        perror(\"Binding failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1)\n    {\n        char* checksumBinary;\n        unsigned int clientAddrLen = sizeof(clientAddr);\n\n        memset(buffer, 0, MAX_BUFFER_SIZE);\n\n        // Receive binary code from client\n        int len = recvfrom(sockfd, buffer, MAX_BUFFER_SIZE, MSG_WAITALL,\n                           (struct sockaddr*)&clientAddr, &clientAddrLen);\n\n        if (len < 0)\n        {\n            perror(\"Error in receiving message\");\n            exit(EXIT_FAILURE);\n        }\n\n        // Calculate checksum and get as binary string\n        checksumBinary = calculateChecksum(buffer);\n\n        printf(\"Received Binary Code: %s\\n\", buffer);\n        printf(\"Calculated Checksum: %s\\n\", checksumBinary);\n\n        // Send the checksum back to the client\n        if (sendto(sockfd, checksumBinary, strlen(checksumBinary), 0,\n                   (struct sockaddr*)&clientAddr, clientAddrLen) < 0)\n        {\n            perror(\"Error in sending message\");\n            exit(EXIT_FAILURE);\n        }\n\n        free(checksumBinary);\n    }\n\n    close(sockfd);\n\n    return 0;\n} \n\n \n\n // Socket Programming using UDP \n // client.c \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main()\n{\n    int sockfd;\n    struct sockaddr_in serverAddr;\n\n    // Create UDP socket\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd < 0)\n    {\n        perror(\"Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&serverAddr, 0, sizeof(serverAddr));\n\n    // Configure server address\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(12345); // Server port number\n    serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // Server IP address\n\n    char binaryCode[16];\n\n    printf(\"Enter a 15-digit binary code: \");\n    fgets(binaryCode, sizeof(binaryCode), stdin);\n\n    // Send the binary code to the server\n    if (sendto(sockfd, binaryCode, strlen(binaryCode), 0,\n               (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0)\n    {\n        perror(\"Error in sending message\");\n        exit(EXIT_FAILURE);\n    }\n\n    char checksumBinary[6]; // 5 bits + null terminator\n    memset(checksumBinary, 0, sizeof(checksumBinary));\n\n    // Receive the checksum from the server\n    if (recvfrom(sockfd, checksumBinary, sizeof(checksumBinary), MSG_WAITALL,\n                  NULL, NULL) < 0)\n    {\n        perror(\"Error in receiving message\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Received Checksum: %s\\n\", checksumBinary);\n\n    close(sockfd);\n\n    return 0;\n} \n\n // \n // server.c \n\n #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#define MAX_BUFFER_SIZE 1024\n#define SERVER_PORT 8080\n\n// Function to find the shortest path using Dijkstra's algorithm\n// Implementation of the algorithm goes here\n\nint main() {\n    int serverSocket, clientSocket;\n    struct sockaddr_in serverAddress, clientAddress;\n    char buffer[MAX_BUFFER_SIZE];\n\n    // Create server socket\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket < 0) {\n        perror(\"Error creating socket\");\n        exit(1);\n    }\n\n    // Prepare server address structure\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(SERVER_PORT);\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n\n    // Bind the socket to the server address\n    if (bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {\n        perror(\"Error binding\");\n        exit(1);\n    }\n\n    // Listen for client connections\n    if (listen(serverSocket, 5) < 0) {\n        perror(\"Error listening\");\n        exit(1);\n    }\n\n    printf(\"Server listening on port %d\\n\", SERVER_PORT);\n\n    // Accept client connections\n    socklen_t clientAddressLength = sizeof(clientAddress);\n    clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddress, &clientAddressLength);\n    if (clientSocket < 0) {\n        perror(\"Error accepting connection\");\n        exit(1);\n    }\n\n    printf(\"Client connected\\n\");\n\n    // Receive data from the client\n    memset(buffer, 0, MAX_BUFFER_SIZE);\n    if (recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0) < 0) {\n        perror(\"Error receiving data\");\n        exit(1);\n    }\n\n    // Process the received data and find the shortest path using Dijkstra's algorithm\n    // ...\n\n    // Send the result back to the client\n    char result[MAX_BUFFER_SIZE] = \"Shortest path: ...\";  // Replace \"...\" with the actual result\n    if (send(clientSocket, result, strlen(result), 0) < 0) {\n        perror(\"Error sending data\");\n        exit(1);\n    }\n\n    // Close the sockets\n    close(clientSocket);\n    close(serverSocket);\n\n    return 0;\n} \n\n // client.c \n\n #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define MAX_BUFFER_SIZE 1024\n#define SERVER_PORT 8080\n#define SERVER_ADDRESS \"127.0.0.1\"\n\nint main() {\n    int clientSocket;\n    struct sockaddr_in serverAddress;\n    char buffer[MAX_BUFFER_SIZE];\n\n    // Create client socket\n    clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (clientSocket < 0) {\n        perror(\"Error creating socket\");\n        exit(1);\n    }\n\n    // Prepare server address structure\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(SERVER_PORT);\n    if (inet_pton(AF_INET, SERVER_ADDRESS, &(serverAddress.sin_addr)) <= 0) {\n        perror(\"Error converting server address\");\n        exit(1);\n    }\n\n    // Connect to the server\n    if (connect(clientSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {\n        perror(\"Error connecting to server\");\n        exit(1);\n    }\n\n    printf(\"Connected to server\\n\");\n\n    // Send data to the server\n    char data[] = \"Graph data...\";  // Replace \"Graph data...\" with the actual graph data\n    if (send(clientSocket, data, strlen(data), 0) < 0) {\n        perror(\"Error sending data\");\n        exit(1);\n    }\n\n    // Receive the result from the server\n    memset(buffer, 0, MAX_BUFFER_SIZE);\n    if (recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0) < 0) {\n        perror(\"Error receiving data\");\n        exit(1);\n    }\n\n    printf(\"Result: %s\\n\", buffer);\n\n    // Close the socket\n    close(clientSocket);\n\n    return 0;\n} "
    }
]