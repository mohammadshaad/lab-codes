[
  {
    "title": "Biggest of Three Numbers",
    "code": "#!/bin/bash\n\necho \"Enter the first number:\"\nread num1\n\necho \"Enter the second number:\"\nread num2\n\necho \"Enter the third number:\"\nread num3\n\n# Initialize the biggest variable to the first number\nbiggest=$num1\n\n# Check if the second number is bigger than the current biggest\nif [ $num2 -gt $biggest ]\nthen\n  biggest=$num2\nfi\n\n# Check if the third number is bigger than the current biggest\nif [ $num3 -gt $biggest ]\nthen\n  biggest=$num3\nfi\n\necho \"The biggest number is: $biggest\"\n"
  },
  {
    "title": "Armstrong Number",
    "code": "#!/bin/bash\n\necho \"Enter a number:\"\nread num\n\n# Count the number of digits\nn=${#num}\n\n# Initialize the sum variable\nsum=0\n\n# Iterate over each digit\nfor (( i=0; i<$n; i++ ))\ndo\n  # Extract the digit at position i\ndigit=${num:i:1}\n\n  # Add the digit raised to the power of n to the sum\n  sum=$(( $sum + $digit ** $n ))\ndone\n\n# Check if the sum is equal to the original number\nif [ $sum -eq $num ]\nthen\n  echo \"$num is an Armstrong number\"\nelse\n  echo \"$num is not an Armstrong number\"\nfi\n"
  },
  {
    "title": "Reverse the Number",
    "code": "#!/bin/bash\n\n echo \"Enter a number:\"\n read num\n \n # Initialize the reversed variable\n reversed=0\n \n # Loop until the number becomes 0\n while [ $num -ne 0 ]\n do\n # Extract the last digit of the number\n digit=$(( $num % 10 ))\n \n # Append the digit to the reversed number\n reversed=$(( $reversed * 10 + $digit ))\n \n # Remove the last digit from the number\n num=$(( $num / 10 ))\n done\n \n echo \"The reversed number is: $reversed\"\n"
  },
  {
    "title": "Fibonacci Series",
    "code": "#!/bin/bash\n\necho \"Enter the number of terms in the Fibonacci series:\"\nread n\n\n# Initialize the first two terms\na=0\nb=1\n\necho \"The Fibonacci series is:\"\n\n# Loop to generate the series\nfor (( i=0; i<$n; i++ ))\ndo\n echo -n \"$a \"\n\n \n next=$(( $a + $b ))\n\n # Update the values of a and b for the next iteration\n a=$b\n b=$next\ndone\n\necho"
  },
  {
    "title": "Sum of Series",
    "code": "#!/bin/bash\n\nsum=0\ni=1\necho \"Enter the number of terms:\"\nread n\necho \"Enter the numbers:\"\nwhile [ $i -le $n ]\ndo\n  read a\n  sum=`expr $a + $sum`\n  i=`expr $i + 1`\ndone\necho \"Sum is $sum\"\n"
  },
  {
    "title": "Week of the Day",
    "code": "echo Enter First Character of Week\nread c\ncase \"$c\" in\n\"M\")\necho The Week of the Day is Monday;;\n\"T\")\necho The Week of the Day is Tuesday;;\n\"W\")\necho The Week of the Day is Wednesday;;\n\"t\")\necho The Week of the Day is Thursday;;\n\"F\")\necho The Week of the Day is Friday;;\n\"S\"):\necho The Week of the Day is Saturday;;\n\"s\")\necho The Week of the Day is Sunday;;\n*)\necho “Invalid Starting Character”;\nesac"
  },
  {
    "title": "Zombie Process",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main (){\n // Fork returns process id in parent process\n pid_t child_pid = fork ();\n // Parent process\n if (child_pid > 0) {\n sleep(50);\n printf(\"Zombie Parent \n\");\n }\n // Child process\n else {\n printf (\"Zombie Child\n\");\n exit(0);\n }\n return 0;\n}"
  },
  {
    "title": "Orphan Process (1st Program)",
    "code": "#include<stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(){\n    // Create a child process\n    int pid = fork();\n\n    if (pid > 0) {\n        printf(\"Orphan Parent \\n\");\n    }\n    // Note that pid is 0 in child process and negative if fork() fails\n    else if (pid == 0) {\n        sleep(30);\n        printf(\"Orphan Child \\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "title": "Orphan Process (2nd Program)",
    "code": "#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n  // fork() Create a child process\n  int pid = fork();\n\n  if (pid > 0) {\n    // getpid() returns process id, while getppid() will return parent process id\n    printf(\"Parent process\\n\");\n    printf(\"ID : %d\\n\\n\", getpid());\n  }\n  else if (pid == 0) {\n    // getpid() will return process id of child process\n    // getppid() will return parent process id of child process\n    printf(\"Child process\\n\");\n    printf(\"ID: %d\\n\", getpid());\n    printf(\"Parent -ID: %d\\n\\n\", getppid());\n    sleep(10);\n    // At this time parent process has finished.\n    // So if u will check parent process id, it will show different process id\n    printf(\"\\nChild process \\n\");\n    printf(\"ID: %d\\n\", getpid());\n    printf(\"Parent -ID: %d\\n\", getppid());\n  }\n  else {\n    printf(\"Failed to create child process\");\n  }\n\n  return 0;\n}"
  },
  {
    "title": "FCFS without Arrival Time",
    "code": "#include <stdio.h>\n\nvoid main()\n{\n    int n, i, bt[20], wt[20], tat[20], total_wt = 0, total_tat = 0;\n    float avg_wt, avg_tat;\n\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter Burst Time:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"P[%d]:\", i + 1);\n        scanf(\"%d\", &bt[i]);\n    }\n\n    wt[0] = 0;\n    for (i = 1; i < n; i++)\n    {\n        wt[i] = wt[i - 1] + bt[i - 1];\n        total_wt += wt[i];\n    }\n\n    for (i = 0; i < n; i++)\n    {\n        tat[i] = bt[i] + wt[i];\n        total_tat += tat[i];\n    }\n\n    avg_wt = (float)total_wt / n;\n    avg_tat = (float)total_tat / n;\n\n    printf(\"\\nProcess\\t    Burst Time    \\tWaiting Time\\tTurnaround Time\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\nP[%d]\\t\\t  %d\\t\\t    %d\\t\\t\\t%d\", i + 1, bt[i], wt[i], tat[i]);\n    }\n\n    printf(\"\\n\\nAverage Waiting Time = %0.2f\", avg_wt);\n    printf(\"\\nAverage Turnaround Time = %0.2f\\n\", avg_tat);\n}"
  },
  {
    "title": "Shortest Job First (SJF) with no preemption",
    "code": "#include <stdio.h>\n\nvoid main()\n{\n    int bt[20], wt[20], tat[20], p[20], i, j, n, total = 0, pos, temp;\n    float avg_wt, avg_tat;\n\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n\n    printf(\"\\nEnter Burst Time:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"P[%d]:\", i + 1);\n        scanf(\"%d\", &bt[i]);\n        p[i] = i + 1;\n    }\n\n    // sorting burst time in ascending order\n    for (i = 0; i < n; i++)\n    {\n        pos = i;\n        for (j = i + 1; j < n; j++)\n        {\n            if (bt[j] < bt[pos])\n                pos = j;\n        }\n\n        temp = bt[i];\n        bt[i] = bt[pos];\n        bt[pos] = temp;\n\n        temp = p[i];\n        p[i] = p[pos];\n        p[pos] = temp;\n    }\n\n    // calculating waiting time and turnaround time\n    wt[0] = 0;\n    for (i = 1; i < n; i++)\n    {\n        wt[i] = 0;\n        for (j = 0; j < i; j++)\n            wt[i] += bt[j];\n\n        total += wt[i];\n    }\n\n    avg_wt = (float)total / n;\n    total = 0;\n\n    printf(\"\\nProcess\\t    Burst Time    \\tWaiting Time\\tTurnaround Time\");\n    for (i = 0; i < n; i++)\n    {\n        tat[i] = bt[i] + wt[i];\n        total += tat[i];\n        printf(\"\\nP[%d]\\t\\t  %d\\t\\t    %d\\t\\t\\t%d\", p[i], bt[i], wt[i], tat[i]);\n    }\n\n    avg_tat = (float)total / n;\n    printf(\"\\n\\nAverage Waiting Time = %0.2f\", avg_wt);\n    printf(\"\\nAverage Turnaround Time = %0.2f\\n\", avg_tat);\n}"
  },
  {
    "title": "Priority Scheduling Algorithm without Preemption",
    "code": "#include <stdio.h>\n\nvoid main()\n{\n    int n, i, j, temp, bt[20], p[20], wt[20], tat[20], pr[20], total_wt = 0, total_tat = 0;\n    float avg_wt, avg_tat;\n\n    printf(\"Enter Total Number of Processes: \");\n    scanf(\"%d\", &n);\n\n    printf(\"\\nEnter Burst Time and Priority For %d Processes\\n\", n);\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\nProcess[%d]\\n\", i + 1);\n        printf(\"Burst Time:\");\n        scanf(\"%d\", &bt[i]);\n        printf(\"Priority:\");\n        scanf(\"%d\", &pr[i]);\n        p[i] = i + 1;\n    }\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n            if (pr[i] > pr[j])\n            {\n                temp = pr[i];\n                pr[i] = pr[j];\n                pr[j] = temp;\n\n                temp = bt[i];\n                bt[i] = bt[j];\n                bt[j] = temp;\n\n                temp = p[i];\n                p[i] = p[j];\n                p[j] = temp;\n            }\n        }\n    }\n\n    wt[0] = 0;\n    for (i = 1; i < n; i++)\n    {\n        wt[i] = 0;\n        for (j = 0; j < i; j++)\n            wt[i] += bt[j];\n\n        total_wt += wt[i];\n    }\n\n    for (i = 0; i < n; i++)\n    {\n        tat[i] = bt[i] + wt[i];\n        total_tat += tat[i];\n    }\n\n    avg_wt = (float)total_wt / n;\n    avg_tat = (float)total_tat / n;\n\n    printf(\"\\n\\nProcess\\t    Burst Time\\t    Priority\\tWaiting Time\\tTurnaround Time\");\n    for (i = 0; i < n; i++)\n        printf(\"\\n%d\\t\\t%d\\t\\t%d\\t\\t%d\\t\\t%d\", p[i], bt[i], pr[i], wt[i], tat[i]);\n\n    printf(\"\\n\\nAverage Waiting Time = %0.2f\", avg_wt);\n    printf(\"\\nAverage Turnaround Time = %0.2f\\n\", avg_tat);\n}"
  },
  {
    "title": "FCFS Scheduling Algorithm with Arrival Time",
    "code": "#include<stdio.h>\n\nvoid main()\n{\n    int n, i, j, wt[20], tat[20], total_wt = 0, total_tat = 0, at[20], bt[20];\n    float avg_wt, avg_tat;\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n    printf(\"Enter arrival time and burst time of processes:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Process %d\\n\", i + 1);\n        printf(\"Arrival Time:\");\n        scanf(\"%d\", &at[i]);\n        printf(\"Burst Time:\");\n        scanf(\"%d\", &bt[i]);\n    }\n\n    // calculate waiting time\n    wt[0] = 0;\n    for (i = 1; i < n; i++)\n    {\n        wt[i] = 0;\n        for (j = 0; j < i; j++)\n        {\n            wt[i] += bt[j];\n        }\n        wt[i] -= at[i];\n        total_wt += wt[i];\n    }\n    avg_wt = (float)total_wt / n;\n\n    // calculate turnaround time\n    for (i = 0; i < n; i++)\n    {\n        tat[i] = bt[i] + wt[i];\n        total_tat += tat[i];\n    }\n    avg_tat = (float)total_tat / n;\n\n    // display results\n    printf(\"\\nProcess\\t  Arrival Time\\t  Burst Time\\t  Waiting Time\\t  Turnaround Time\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"P%d\\t\\t%d\\t\\t%d\\t\\t%d\\t\\t%d\\n\", i + 1, at[i], bt[i], wt[i], tat[i]);\n    }\n    printf(\"\\nAverage waiting time = %0.2f\\n\", avg_wt);\n    printf(\"Average turnaround time = %0.2f\\n\", avg_tat);\n}"
  },
  {
    "title": "SJF Scheduling Algorithm with Preemption",
    "code": "#include <stdio.h>\n\nint main()\n{\n    int n, bt[20], wt[20], tat[20], p[20], i, j, smallest, time = 0, remain, total_tat = 0, total_wt = 0;\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n    remain = n;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Enter burst time for process %d:\", i + 1);\n        scanf(\"%d\", &bt[i]);\n        p[i] = i + 1;\n    }\n\n    // sort burst time in ascending order using selection sort\n    for (i = 0; i < n; i++)\n    {\n        smallest = i;\n        for (j = i + 1; j < n; j++)\n        {\n            if (bt[j] < bt[smallest])\n            {\n                smallest = j;\n            }\n        }\n        int temp = bt[i];\n        bt[i] = bt[smallest];\n        bt[smallest] = temp;\n        temp = p[i];\n        p[i] = p[smallest];\n        p[smallest] = temp;\n    }\n\n    // calculate waiting time and turnaround time\n    for (i = 0; i < n; i++)\n    {\n        wt[i] = 0;\n        for (j = 0; j < i; j++)\n        {\n            wt[i] += bt[j];\n        }\n        tat[i] = bt[i] + wt[i];\n        total_wt += wt[i];\n        total_tat += tat[i];\n    }\n\n    // display results\n    printf(\"\\nProcess\\t  Burst Time\\t  Waiting Time\\t  Turnaround Time\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"P%d\\t\\t%d\\t\\t%d\\t\\t%d\\n\", p[i], bt[i], wt[i], tat[i]);\n    }\n    float avg_wt = (float)total_wt / n;\n    float avg_tat = (float)total_tat / n;\n    printf(\"\\nAverage waiting time = %0.2f\\n\", avg_wt);\n    printf(\"Average turnaround time = %0.2f\\n\", avg_tat);\n\n    return 0;\n}"
  },
  {
    "title": "Priority Scheduling Algorithm with Preemption",
    "code": "#include <stdio.h>\n\nint main()\n{\n    int n, bt[20], wt[20], tat[20], p[20], priority[20], i, j, pos, temp, time = 0, remain, total_tat = 0, total_wt = 0;\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n    remain = n;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Enter burst time and priority for process %d:\", i + 1);\n        scanf(\"%d %d\", &bt[i], &priority[i]);\n        p[i] = i + 1;\n    }\n\n    // sort processes by priority in descending order using selection sort\n    for (i = 0; i < n; i++)\n    {\n        pos = i;\n        for (j = i + 1; j < n; j++)\n        {\n            if (priority[j] > priority[pos])\n            {\n                pos = j;\n            }\n        }\n        temp = priority[i];\n        priority[i] = priority[pos];\n        priority[pos] = temp;\n        temp = bt[i];\n        bt[i] = bt[pos];\n        bt[pos] = temp;\n        temp = p[i];\n        p[i] = p[pos];\n        p[pos] = temp;\n    }\n\n    // calculate waiting time and turnaround time\n    for (i = 0; i < n; i++)\n    {\n        wt[i] = 0;\n        for (j = 0; j < i; j++)\n        {\n            wt[i] += bt[j];\n        }\n        tat[i] = bt[i] + wt[i];\n        total_wt += wt[i];\n        total_tat += tat[i];\n    }\n\n    // display results\n    printf(\"\\nProcess\\t  Burst Time\\t  Priority\\t  Waiting Time\\t  Turnaround Time\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"P%d\\t\\t%d\\t\\t%d\\t\\t%d\\t\\t%d\\n\", p[i], bt[i], priority[i], wt[i], tat[i]);\n    }\n    float avg_wt = (float)total_wt / n;\n    float avg_tat = (float)total_tat / n;\n    printf(\"\\nAverage waiting time = %0.2f\\n\", avg_wt);\n    printf(\"Average turnaround time = %0.2f\\n\", avg_tat);\n\n    return 0;\n}"
  },
  {
    "title": "Round Robin Scheduling Algorithm",
    "code": "#include <stdio.h>\n\nint main()\n{\n    int i, n, quantum, total_wt = 0, total_tat = 0;\n    int bt[20], wt[20], tat[20], rem_bt[20];\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n    printf(\"Enter burst time for each process:\");\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &bt[i]);\n        rem_bt[i] = bt[i];\n    }\n    printf(\"Enter time quantum:\");\n    scanf(\"%d\", &quantum);\n    int time = 0;\n    while (1)\n    {\n        int done = 1;\n        for (i = 0; i < n; i++)\n        {\n            if (rem_bt[i] > 0)\n            {\n                done = 0;\n                if (rem_bt[i] > quantum)\n                {\n                    time += quantum;\n                    rem_bt[i] -= quantum;\n                }\n                else\n                {\n                    time += rem_bt[i];\n                    wt[i] = time - bt[i];\n                    rem_bt[i] = 0;\n                }\n            }\n        }\n        if (done == 1)\n            break;\n    }\n    for (i = 0; i < n; i++)\n    {\n        tat[i] = bt[i] + wt[i];\n        total_wt += wt[i];\n        total_tat += tat[i];\n    }\n    float avg_wt = (float)total_wt / n;\n    float avg_tat = (float)total_tat / n;\n    printf(\"\\nProcess\\t  Burst Time\\t  Waiting Time\\t  Turnaround Time\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d\\t\\t%d\\t\\t%d\\t\\t%d\\n\", i + 1, bt[i], wt[i], tat[i]);\n    }\n    printf(\"\\nAverage waiting time = %0.2f\\n\", avg_wt);\n    printf(\"Average turnaround time = %0.2f\\n\", avg_tat);\n    return 0;\n}"
  },
  {
    "title": "Semaphore Example",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n\nsem_t sem;\n\nvoid *child_thread(void *arg)\n{\n    int i;\n    for (i = 0; i < 5; i++) {\n        printf(\"VIT University\\n\");\n    }\n    sem_post(&sem);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[])\n{\n    pthread_t tid;\n    sem_init(&sem, 0, 0);\n    if (pthread_create(&tid, NULL, child_thread, NULL) != 0) {\n        fprintf(stderr, \"Failed to create thread\\n\");\n        exit(1);\n    }\n    sem_wait(&sem);\n    printf(\"Parent Ends\\n\");\n    sem_destroy(&sem);\n    pthread_exit(NULL);\n}"
  },
  {
    "title": "Producer-Consumer Problem using Semaphores",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\nint buffer_index = 0;\nsem_t full, empty, mutex;\n\nvoid *producer(void *arg)\n{\n    int i;\n    for (i = 0; i < 10; i++) {\n        sem_wait(&empty);\n        sem_wait(&mutex);\n        buffer[buffer_index++] = i;\n        printf(\"Produced: %d\\n\", i);\n        sem_post(&mutex);\n        sem_post(&full);\n    }\n    pthread_exit(NULL);\n}\n\nvoid *consumer(void *arg)\n{\n    int i;\n    while(1) {\n        sem_wait(&full);\n        sem_wait(&mutex);\n        int item = buffer[--buffer_index];\n        printf(\"Consumed: %d\\n\", item);\n        sem_post(&mutex);\n        sem_post(&empty);\n    }\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[])\n{\n    pthread_t producer_thread, consumer_thread;\n    sem_init(&empty, 0, BUFFER_SIZE);\n    sem_init(&full, 0, 0);\n    sem_init(&mutex, 0, 1);\n    if (pthread_create(&producer_thread, NULL, producer, NULL) != 0) {\n        fprintf(stderr, \"Failed to create producer thread\\n\");\n        exit(1);\n    }\n    if (pthread_create(&consumer_thread, NULL, consumer, NULL) != 0) {\n        fprintf(stderr, \"Failed to create consumer thread\\n\");\n        exit(1);\n    }\n    if (pthread_join(producer_thread, NULL) != 0) {\n        fprintf(stderr, \"Failed to join producer thread\\n\");\n        exit(1);\n    }\n    if (pthread_join(consumer_thread, NULL) != 0) {\n        fprintf(stderr, \"Failed to join consumer thread\\n\");\n        exit(1);\n    }\n    sem_destroy(&empty);\n    sem_destroy(&full);\n    sem_destroy(&mutex);\n    pthread_exit(NULL);\n}"
  },
  {
    "title": "Dining Philosophers Problem using Semaphores",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#define NUM_PHILOSOPHERS 5\nsem_t forks[NUM_PHILOSOPHERS];\nsem_t waiter;\nvoid *philosopher(void *arg)\n{\n    int id = *(int *) arg;\n    int left_fork = id;\n    int right_fork = (id + 1) % NUM_PHILOSOPHERS;\n    while(1) {\n        printf(\"Philosopher %d is thinking\\n\", id);\n        sleep(1);\n        sem_wait(&waiter);\n        sem_wait(&forks[left_fork]);\n        printf(\"Philosopher %d picked up left fork %d\\n\", id, left_fork);\n        sem_wait(&forks[right_fork]);\n        printf(\"Philosopher %d picked up right fork %d\\n\", id, right_fork);\n        sem_post(&waiter);\n        printf(\"Philosopher %d is eating\\n\", id);\n        sleep(2);\n        sem_post(&forks[left_fork]);\n        printf(\"Philosopher %d put down left fork %d\\n\", id, left_fork);\n        sem_post(&forks[right_fork]);\n        printf(\"Philosopher %d put down right fork %d\\n\", id, right_fork);\n    }\n    pthread_exit(NULL);\n}\nint main(int argc, char *argv[])\n{\n    pthread_t philosophers[NUM_PHILOSOPHERS];\n    int ids[NUM_PHILOSOPHERS];\n    int i;\n    for (i = 0; i < NUM_PHILOSOPHERS; i++) {\n        sem_init(&forks[i], 0, 1);\n    }\n    sem_init(&waiter, 0, NUM_PHILOSOPHERS - 1);\n    for (i = 0; i < NUM_PHILOSOPHERS; i++) {\n        ids[i] = i;\n        if (pthread_create(&philosophers[i], NULL, philosopher, &ids[i]) != 0) {\n            fprintf(stderr, \"Failed to create philosopher thread %d\\n\", i);\n            exit(1);\n        }\n    }\n    for (i = 0; i < NUM_PHILOSOPHERS; i++) {\n        if (pthread_join(philosophers[i], NULL) != 0) {\n            fprintf(stderr, \"Failed to join philosopher thread %d\\n\", i);\n            exit(1);\n        }\n    }\n    sem_destroy(&waiter);\n    for (i = 0; i < NUM_PHILOSOPHERS; i++) {\n        sem_destroy(&forks[i]);\n    }\n    pthread_exit(NULL);\n}"
  },
  {
    "title": "Reader Writer Problem using Semaphores",
    "code": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NUM_READERS 5\n#define NUM_WRITERS 2\n#define NUM_ITERATIONS 10\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t read_cv = PTHREAD_COND_INITIALIZER;\npthread_cond_t write_cv = PTHREAD_COND_INITIALIZER;\n\nint shared_data = 0;\nint num_readers = 0;\nint num_writers = 0;\n\nvoid *reader(void *arg) {\n    int i;\n    for (i = 0; i < NUM_ITERATIONS; i++) {\n        pthread_mutex_lock(&mutex);\n        while (num_writers > 0) {\n            pthread_cond_wait(&read_cv, &mutex);\n        }\n        num_readers++;\n        pthread_mutex_unlock(&mutex);\n        printf(\"Reader %d read shared data as %d\\n\", *((int*)arg), shared_data);\n        pthread_mutex_lock(&mutex);\n        num_readers--;\n        if (num_readers == 0) {\n            pthread_cond_signal(&write_cv);\n        }\n        pthread_mutex_unlock(&mutex);\n    }\n    return NULL;\n}\n\nvoid *writer(void *arg) {\n    int i;\n    for (i = 0; i < NUM_ITERATIONS; i++) {\n        pthread_mutex_lock(&mutex);\n        while (num_writers > 0 || num_readers > 0) {\n            pthread_cond_wait(&write_cv, &mutex);\n        }\n        num_writers++;\n        shared_data++;\n        printf(\"Writer %d wrote shared data as %d\\n\", *((int*)arg), shared_data);\n        num_writers--;\n        pthread_cond_signal(&read_cv);\n        pthread_cond_signal(&write_cv);\n        pthread_mutex_unlock(&mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    int i;\n    pthread_t readers[NUM_READERS];\n    pthread_t writers[NUM_WRITERS];\n    int reader_args[NUM_READERS];\n    int writer_args[NUM_WRITERS];\n    \n    for (i = 0; i < NUM_READERS; i++) {\n        reader_args[i] = i;\n        pthread_create(&readers[i], NULL, reader, &reader_args[i]);\n    }\n    for (i = 0; i < NUM_WRITERS; i++) {\n        writer_args[i] = i;\n        pthread_create(&writers[i], NULL, writer, &writer_args[i]);\n    }\n    for (i = 0; i < NUM_READERS; i++) {\n        pthread_join(readers[i], NULL);\n    }\n    for (i = 0; i < NUM_WRITERS; i++) {\n        pthread_join(writers[i], NULL);\n    }\n    return 0;\n}"
  },
  {
    "title": "Banker's Algorithm",
    "code": "#include<stdio.h>\n\nint main()\n{\n    int i, j, n, m, k = 0, count1 = 0, count2 = 0;\n    int avail[10], alloc[10][10], max[10][10], need[10][10], safe[10];\n    int finish[10] = {0};\n\n    printf(\"Enter number of processes:\");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter number of resources:\");\n    scanf(\"%d\", &m);\n\n    printf(\"Enter the available resources:\");\n    for (i = 0; i < m; i++)\n        scanf(\"%d\", &avail[i]);\n\n    printf(\"Enter the allocation matrix:\");\n    for (i = 0; i < n; i++)\n        for (j = 0; j < m; j++)\n            scanf(\"%d\", &alloc[i][j]);\n\n    printf(\"Enter the maximum matrix:\");\n    for (i = 0; i < n; i++)\n        for (j = 0; j < m; j++)\n            scanf(\"%d\", &max[i][j]);\n\n    // calculating need matrix\n    for (i = 0; i < n; i++)\n        for (j = 0; j < m; j++)\n            need[i][j] = max[i][j] - alloc[i][j];\n\n    // checking if a process can be allocated resources or not\n    while (count1 != n)\n    {\n        count2 = count1;\n        for (i = 0; i < n; i++)\n        {\n            for (j = 0; j < m; j++)\n            {\n                if (finish[i] == 0 && need[i][j] <= avail[j])\n                {\n                    k++;\n                }\n                else\n                    break;\n            }\n            if (k == m)\n            {\n                for (j = 0; j < m; j++)\n                    avail[j] += alloc[i][j];\n                safe[count1] = i;\n                finish[i] = 1;\n                count1++;\n            }\n            k = 0;\n        }\n        if (count1 == count2)\n        {\n            printf(\"System is in unsafe state.\");\n            return 0;\n        }\n    }\n\n    printf(\"The system is in safe state.\");\n    printf(\"\\nThe safe sequence is:\");\n    for (i = 0; i < n; i++)\n        printf(\"%d \", safe[i]);\n\n    return 0;\n}"
  },
  {
    "title": "Multi-Threaded Program for Sum of Natural Numbers and Multiplication Table",
    "code": "#include <stdio.h>\n#include <pthread.h>\n\nvoid *sumOfN(void *arg)\n{\n    int n = *((int*)arg);\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    printf(\"Sum of %d natural numbers is: %d\\n\", n, sum);\n}\n\nvoid *multiplicationTable(void *arg)\n{\n    int m = *((int*)arg);\n    for (int i = 1; i <= 10; i++) {\n        printf(\"%d * %d = %d\\n\", m, i, m*i);\n    }\n}\n\nvoid main()\n{\n    pthread_t tid1, tid2;\n    int n = 10;\n    int m = 5;\n\n    pthread_create(&tid1, NULL, sumOfN, (void *)&n);\n    pthread_create(&tid2, NULL, multiplicationTable, (void *)&m);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    printf(\"I am done.\\n\");\n}"
  },
  {
    "title": "Dynamic Memory Allocation ",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n;\n    int *arr;\n    \n    printf(\"Enter the size of the array: \");\n    scanf(\"%d\", &n);\n    \n    // allocate memory for the array\n    arr = (int*)malloc(n * sizeof(int));\n    \n    if (arr == NULL) {\n        printf(\"Memory allocation failed.\");\n        return 1;\n    }\n    \n    // populate the array\n    printf(\"Enter the array elements: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // print the array elements\n    printf(\"The array elements are: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    \n    // free the allocated memory\n    free(arr);\n    arr = NULL;\n    \n    printf(\"\\nMemory freed.\\n\");\n\n    return 0;\n}"
  },
  {
    "title": "Page Replacement Algorithm - FIFO",
    "code": "#include <stdio.h>\n\nint main() {\n    int frames, pages, i, j, k, flag, fault = 0;\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &frames);\n    int frame[frames];\n    printf(\"Enter the number of pages: \");\n    scanf(\"%d\", &pages);\n    int page[pages];\n    printf(\"Enter the reference string: \");\n    for(i = 0; i < pages; i++) {\n        scanf(\"%d\", &page[i]);\n    }\n    for(i = 0; i < frames; i++) {\n        frame[i] = -1;\n    }\n    j = 0;\n    printf(\"\\nReference String\\tPage Frames\\tFaults\\n\");\n    for(i = 0; i < pages; i++) {\n        printf(\"%d\\t\\t\", page[i]);\n        flag = 0;\n        for(k = 0; k < frames; k++) {\n            if(frame[k] == page[i]) {\n                flag = 1;\n            }\n        }\n        if(flag == 0) {\n            frame[j] = page[i];\n            j = (j + 1) % frames;\n            fault++;\n            for(k = 0; k < frames; k++) {\n                printf(\"%d \", frame[k]);\n            }\n        }\n        printf(\"\\t\\t%d\", fault);\n        printf(\"\\n\");\n    }\n    printf(\"\\nTotal Page Faults: %d\\n\", fault);\n    return 0;\n}"
  },
  {
    "title": "Optimal Page Replacement Algorithm",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int frames, pages, faults = 0, next = 0, k = 0, max, farthest, flag1, flag2, hit = 0;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &frames);\n    int frame[frames], ref[pages];\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &pages);\n    printf(\"Enter the reference string: \");\n    for (int i = 0; i < pages; i++) {\n        scanf(\"%d\", &ref[i]);\n    }\n    for (int i = 0; i < frames; i++) {\n        frame[i] = -1;\n    }\n    for (int i = 0; i < pages; i++) {\n        flag1 = flag2 = 0;\n        for (int j = 0; j < frames; j++) {\n            if (frame[j] == ref[i]) {\n                flag1 = flag2 = 1;\n                hit++;\n                break;\n            }\n            if (frame[j] == -1) {\n                faults++;\n                frame[j] = ref[i];\n                flag2 = 1;\n                break;\n            }\n        }\n        if (flag1 == 0 && flag2 == 0) {\n            faults++;\n            max = -1;\n            for (int j = 0; j < frames; j++) {\n                for (k = i + 1; k < pages; k++) {\n                    if (frame[j] == ref[k]) {\n                        if (k > max) {\n                            max = k;\n                            farthest = j;\n                        }\n                        break;\n                    }\n                }\n                if (k == pages) {\n                    farthest = j;\n                    break;\n                }\n            }\n            frame[farthest] = ref[i];\n        }\n        printf(\"\\n\");\n        for (int j = 0; j < frames; j++) {\n            printf(\"%d\\t\", frame[j]);\n        }\n    }\n    printf(\"\\nTotal Page Faults = %d\", faults);\n    printf(\"\\nTotal Page Hits = %d\", hit);\n    return 0;\n}\n"
  },
  {
    "title": "LRU Page Replacement Algorithm",
    "code": "#include <stdio.h>\n\nint main() {\n    int n, m, pages[100], frames[10], temp[10], page_faults = 0, flag1, flag2, i, j, k, pos, max, fault, recent = 0;\n    printf(\"Enter the number of pages: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter the page reference string: \");\n    for (i = 0; i < n; ++i) {\n        scanf(\"%d\", &pages[i]);\n    }\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &m);\n    for (i = 0; i < m; ++i) {\n        frames[i] = -1;\n    }\n    for (i = 0; i < n; ++i) {\n        flag1 = flag2 = 0;\n        for (j = 0; j < m; ++j) {\n            if (frames[j] == pages[i]) {\n                page_faults--;\n                flag1 = flag2 = 1;\n                break;\n            }\n        }\n        if (flag1 == 0) {\n            for (j = 0; j < m; ++j) {\n                if (frames[j] == -1) {\n                    page_faults++;\n                    frames[j] = pages[i];\n                    flag2 = 1;\n                    break;\n                }\n            }\n        }\n        if (flag2 == 0) {\n            flag1 = 0;\n            for (j = 0; j < m; ++j) {\n                temp[j] = -1;\n                for (k = i - 1; k >= 0; --k) {\n                    if (frames[j] == pages[k]) {\n                        temp[j] = k;\n                        break;\n                    }\n                }\n            }\n            for (j = 0; j < m; ++j) {\n                if (temp[j] == -1) {\n                    pos = j;\n                    flag1 = 1;\n                    break;\n                }\n            }\n            if (flag1 == 0) {\n                max = temp[0];\n                pos = 0;\n                for (j = 1; j < m; ++j) {\n                    if (temp[j] > max) {\n                        max = temp[j];\n                        pos = j;\n                    }\n                }\n            }\n            frames[pos] = pages[i];\n            page_faults++;\n        }\n        printf(\"\\nAfter %d page reference(s):\", i + 1);\n        for (j = 0; j < m; ++j) {\n            printf(\" %d\", frames[j]);\n        }\n    }\n    printf(\"\\nTotal Page Faults: %d\\n\", page_faults);\n    return 0;\n}"
  },
  {
    "title": "Page Replacement Algorithm - Second Chance",
    "code": "#include <stdio.h>\n\nint main()\n{\n    int n, frames, count = 0, nextReplaceIndex = 0, hits = 0, faults = 0;\n    printf(\"Enter number of page references: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &frames);\n\n    int refString[n], frame[frames], referenceBits[frames];\n\n    printf(\"Enter the page reference string:\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &refString[i]);\n    }\n\n    for (int i = 0; i < frames; i++) {\n        frame[i] = -1;  // Initialize frames with -1\n        referenceBits[i] = 0;  // Initialize reference bits with 0\n    }\n\n    for (int i = 0; i < n; i++) {\n        int j, flag = 0;\n        for (j = 0; j < frames; j++) {\n            if (frame[j] == refString[i]) {\n                referenceBits[j] = 1; // Mark reference bit as 1 for hit pages\n                hits++;\n                flag = 1;\n                break;\n            }\n        }\n\n        if (flag == 0) {\n            while (referenceBits[nextReplaceIndex] == 1) {\n                referenceBits[nextReplaceIndex] = 0; // Reset reference bit to 0 for unselected pages\n                nextReplaceIndex = (nextReplaceIndex + 1) % frames; // Find next page to replace with reference bit 0\n            }\n\n            frame[nextReplaceIndex] = refString[i];\n            referenceBits[nextReplaceIndex] = 1; // Set reference bit as 1 for newly inserted page\n            faults++;\n            nextReplaceIndex = (nextReplaceIndex + 1) % frames; // Find next page to replace\n        }\n\n        printf(\"%2d: \", refString[i]);\n        for (j = 0; j < frames; j++) {\n            if (frame[j] == -1) {\n                printf(\"*\");\n            } else {\n                printf(\"%d\", frame[j]);\n            }\n            printf(\"  %d \", referenceBits[j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\nNumber of page hits: %d\\n\", hits);\n    printf(\"Number of page faults: %d\\n\", faults);\n    return 0;\n}"
  },
  {
    "title": "C program to lock a file and display its contents",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main(int argc, char *argv[])\n{\n    struct flock filelock;\n    int fd, ret;\n    char buf[1024];\n    ssize_t nread;\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        exit(1);\n    }\n    fd = open(argv[1], O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(1);\n    }\n    filelock.l_type = F_WRLCK;\n    filelock.l_whence = SEEK_SET;\n    filelock.l_start = 0;\n    filelock.l_len = 0;\n    ret = fcntl(fd, F_SETLK, &filelock);\n    if (ret == -1) {\n        if (errno == EACCES || errno == EAGAIN) {\n            printf(\"File is locked.\\n\");\n            exit(2);\n        }\n        perror(\"fcntl\");\n        exit(1);\n    }\n    printf(\"File is locked.\\n\");\n    sleep(5);\n    filelock.l_type = F_UNLCK;\n    ret = fcntl(fd, F_SETLK, &filelock);\n    if (ret == -1) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    printf(\"File unlocked.\\n\");\n    lseek(fd, 0, SEEK_SET);\n    while ((nread = read(fd, buf, sizeof(buf))) > 0) {\n        write(STDOUT_FILENO, buf, nread);\n    }\n    close(fd);\n    return 0;\n}"
  },
  {
    "title": "Check if a file is locked or unlocked",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/file.h>\n\nint main(int argc, char *argv[]) {\n    int fd;\n    char *filename;\n    if (argc != 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        exit(1);\n    }\n    filename = argv[1];\n    fd = open(filename, O_RDONLY);\n    if (fd == -1) {\n        printf(\"Cannot open file %s: %s\\n\", filename, strerror(errno));\n        exit(1);\n    }\n    if (flock(fd, LOCK_EX | LOCK_NB) == -1) {\n        printf(\"File %s is locked.\\n\", filename);\n    } else {\n        printf(\"File %s is unlocked.\\n\", filename);\n    }\n    close(fd);\n    return 0;\n}"
  }
]
